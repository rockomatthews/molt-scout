import { NextResponse } from "next/server";
import crypto from "node:crypto";

export const dynamic = "force-dynamic";

function timingSafeEq(a: string, b: string) {
  const aa = Buffer.from(a);
  const bb = Buffer.from(b);
  if (aa.length !== bb.length) return false;
  return crypto.timingSafeEqual(aa, bb);
}

function verifySignature({ secret, raw, signature }: { secret: string; raw: string; signature: string }) {
  const mac = crypto.createHmac("sha256", secret).update(raw).digest("hex");
  return timingSafeEq(mac, signature);
}

// Idempotency store interface (implement with Redis/Postgres)
async function alreadySeen(idempotencyKey: string): Promise<boolean> {
  return false;
}
async function markSeen(idempotencyKey: string): Promise<void> {
  return;
}

export async function POST(req: Request) {
  const secret = process.env.WEBHOOK_SECRET;
  if (!secret) return new NextResponse("missing secret", { status: 500 });

  const raw = Buffer.from(await req.arrayBuffer()).toString("utf8");

  const sig = req.headers.get("x-signature") ?? "";
  if (!sig) return new NextResponse("missing signature", { status: 400 });

  if (!verifySignature({ secret, raw, signature: sig })) {
    return new NextResponse("bad signature", { status: 401 });
  }

  const idem = req.headers.get("x-idempotency-key") ?? crypto.createHash("sha256").update(raw).digest("hex");
  if (await alreadySeen(idem)) return NextResponse.json({ ok: true, duplicate: true });
  await markSeen(idem);

  // Enqueue job here

  return NextResponse.json({ ok: true });
}
