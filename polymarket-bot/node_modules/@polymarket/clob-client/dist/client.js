"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClobClient = void 0;
const tslib_1 = require("tslib");
const types_1 = require("./types");
const headers_1 = require("./headers");
const http_helpers_1 = require("./http-helpers");
const errors_1 = require("./errors");
const utilities_1 = require("./utilities");
const endpoints_1 = require("./endpoints");
const builder_1 = require("./order-builder/builder");
class ClobClient {
    constructor(host, chainId, signer, creds, signatureType, funderAddress) {
        this.host = host.endsWith("/") ? host.slice(0, -1) : host;
        this.chainId = chainId;
        if (signer !== undefined) {
            this.signer = signer;
        }
        if (creds !== undefined) {
            this.creds = creds;
        }
        this.orderBuilder = new builder_1.OrderBuilder(signer, chainId, signatureType, funderAddress);
        this.tickSizes = {};
    }
    // Public endpoints
    getOk() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (0, http_helpers_1.get)(`${this.host}/`);
        });
    }
    getServerTime() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (0, http_helpers_1.get)(`${this.host}${endpoints_1.TIME}`);
        });
    }
    getSamplingSimplifiedMarkets(next_cursor = "MA==") {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (0, http_helpers_1.get)(`${this.host}${endpoints_1.GET_SAMPLING_SIMPLIFIED_MARKETS}?next_cursor=${next_cursor}`);
        });
    }
    getSamplingMarkets(next_cursor = "MA==") {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (0, http_helpers_1.get)(`${this.host}${endpoints_1.GET_SAMPLING_MARKETS}?next_cursor=${next_cursor}`);
        });
    }
    getSimplifiedMarkets(next_cursor = "MA==") {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (0, http_helpers_1.get)(`${this.host}${endpoints_1.GET_SIMPLIFIED_MARKETS}?next_cursor=${next_cursor}`);
        });
    }
    getMarkets(next_cursor = "MA==") {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (0, http_helpers_1.get)(`${this.host}${endpoints_1.GET_MARKETS}?next_cursor=${next_cursor}`);
        });
    }
    getMarket(conditionID) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (0, http_helpers_1.get)(`${this.host}${endpoints_1.GET_MARKET}${conditionID}`);
        });
    }
    getOrderBook(tokenID) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (0, http_helpers_1.get)(`${this.host}${endpoints_1.GET_ORDER_BOOK}?token_id=${tokenID}`);
        });
    }
    getTickSize(tokenID) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (tokenID in this.tickSizes) {
                return this.tickSizes[tokenID];
            }
            const result = yield (0, http_helpers_1.get)(`${this.host}${endpoints_1.GET_TICK_SIZE}?token_id=${tokenID}`);
            this.tickSizes[tokenID] = result.minimum_tick_size;
            return this.tickSizes[tokenID];
        });
    }
    /**
     * Calculates the hash for the given orderbook
     * @param orderbook
     * @returns
     */
    getOrderBookHash(orderbook) {
        return (0, utilities_1.generateOrderBookSummaryHash)(orderbook);
    }
    getMidpoint(tokenID) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (0, http_helpers_1.get)(`${this.host}${endpoints_1.GET_MIDPOINT}?token_id=${tokenID}`);
        });
    }
    getPrice(tokenID, side) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (0, http_helpers_1.get)(`${this.host}${endpoints_1.GET_PRICE}?token_id=${tokenID}&side=${side}`);
        });
    }
    getLastTradePrice(tokenID) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (0, http_helpers_1.get)(`${this.host}${endpoints_1.GET_LAST_TRADE_PRICE}?token_id=${tokenID}`);
        });
    }
    getLargeOrders(minValue = "") {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (0, http_helpers_1.get)(`${this.host}${endpoints_1.GET_LARGE_ORDERS}?min_value=${minValue}`);
        });
    }
    getPricesHistory(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const url = (0, http_helpers_1.addPriceHistoryFilterParamsToUrl)(`${this.host}${endpoints_1.GET_PRICES_HISTORY}`, params);
            return (0, http_helpers_1.get)(url);
        });
    }
    // L1 Authed
    /**
     * Creates a new API key for a user
     * @param nonce
     * @param optionalParams - query parameters
     * @returns ApiKeyCreds
     */
    createApiKey(nonce, optionalParams) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL1Auth();
            const endpoint = `${this.host}${endpoints_1.CREATE_API_KEY}`;
            const headers = yield (0, headers_1.createL1Headers)(this.signer, this.chainId, nonce);
            return yield (0, http_helpers_1.post)(endpoint, headers, undefined, optionalParams).then((apiKeyRaw) => {
                const apiKey = {
                    key: apiKeyRaw.apiKey,
                    secret: apiKeyRaw.secret,
                    passphrase: apiKeyRaw.passphrase,
                };
                return apiKey;
            });
        });
    }
    /**
     * Derives an existing API key for a user
     * @param nonce
     * @param optionalParams - query parameters
     * @returns ApiKeyCreds
     */
    deriveApiKey(nonce, optionalParams) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL1Auth();
            const endpoint = `${this.host}${endpoints_1.DERIVE_API_KEY}`;
            const headers = yield (0, headers_1.createL1Headers)(this.signer, this.chainId, nonce);
            return yield (0, http_helpers_1.get)(endpoint, headers, undefined, optionalParams).then((apiKeyRaw) => {
                const apiKey = {
                    key: apiKeyRaw.apiKey,
                    secret: apiKeyRaw.secret,
                    passphrase: apiKeyRaw.passphrase,
                };
                return apiKey;
            });
        });
    }
    createOrDeriveApiKey(nonce, optionalParams) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.createApiKey(nonce, optionalParams).then(response => {
                if (!response.key) {
                    return this.deriveApiKey(nonce, optionalParams);
                }
                return response;
            });
        });
    }
    getApiKeys() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL2Auth();
            const endpoint = endpoints_1.GET_API_KEYS;
            const headerArgs = {
                method: http_helpers_1.GET,
                requestPath: endpoint,
            };
            const headers = yield (0, headers_1.createL2Headers)(this.signer, this.creds, headerArgs);
            return (0, http_helpers_1.get)(`${this.host}${endpoint}`, headers).then((apiKeyRaw) => {
                const apiKey = {
                    key: apiKeyRaw.apiKey,
                    secret: apiKeyRaw.secret,
                    passphrase: apiKeyRaw.passphrase,
                };
                return { apiKeys: [apiKey] };
            });
        });
    }
    deleteApiKey() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL2Auth();
            const endpoint = endpoints_1.DELETE_API_KEY;
            const headerArgs = {
                method: http_helpers_1.DELETE,
                requestPath: endpoint,
            };
            const headers = yield (0, headers_1.createL2Headers)(this.signer, this.creds, headerArgs);
            return (0, http_helpers_1.del)(`${this.host}${endpoint}`, headers);
        });
    }
    getOrder(orderID) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL2Auth();
            const endpoint = `${endpoints_1.GET_ORDER}${orderID}`;
            const headerArgs = {
                method: http_helpers_1.GET,
                requestPath: endpoint,
            };
            const headers = yield (0, headers_1.createL2Headers)(this.signer, this.creds, headerArgs);
            return (0, http_helpers_1.get)(`${this.host}${endpoint}`, headers);
        });
    }
    getTrades(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL2Auth();
            const endpoint = endpoints_1.GET_TRADES;
            const headerArgs = {
                method: http_helpers_1.GET,
                requestPath: endpoint,
            };
            const headers = yield (0, headers_1.createL2Headers)(this.signer, this.creds, headerArgs);
            const url = (0, http_helpers_1.addTradeParamsToUrl)(`${this.host}${endpoint}`, params);
            return (0, http_helpers_1.get)(url, headers);
        });
    }
    getTradeNotifications(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL2Auth();
            const endpoint = endpoints_1.GET_TRADE_NOTIFICATIONS;
            const headerArgs = {
                method: http_helpers_1.GET,
                requestPath: endpoint,
            };
            const headers = yield (0, headers_1.createL2Headers)(this.signer, this.creds, headerArgs);
            const url = (0, http_helpers_1.addTradeNotificationParamsToUrl)(`${this.host}${endpoint}`, params);
            return (0, http_helpers_1.get)(url, headers);
        });
    }
    dropTradeNotifications(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL2Auth();
            const endpoint = endpoints_1.DROP_TRADE_NOTIFICATIONS;
            const l2HeaderArgs = {
                method: http_helpers_1.DELETE,
                requestPath: endpoint,
            };
            const headers = yield (0, headers_1.createL2Headers)(this.signer, this.creds, l2HeaderArgs);
            const url = (0, http_helpers_1.addTradeNotificationParamsToUrl)(`${this.host}${endpoint}`, params);
            return (0, http_helpers_1.del)(url, headers);
        });
    }
    getBalanceAllowance(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL2Auth();
            const endpoint = endpoints_1.GET_BALANCE_ALLOWANCE;
            const headerArgs = {
                method: http_helpers_1.GET,
                requestPath: endpoint,
            };
            const headers = yield (0, headers_1.createL2Headers)(this.signer, this.creds, headerArgs);
            const url = (0, http_helpers_1.addBalanceAllowanceParamsToUrl)(`${this.host}${endpoint}`, params);
            return (0, http_helpers_1.get)(url, headers);
        });
    }
    createOrder(userOrder, tickSize) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL1Auth();
            const { tokenID } = userOrder;
            tickSize = yield this._resolveTickSize(tokenID, tickSize);
            return this.orderBuilder.buildOrder(userOrder, tickSize);
        });
    }
    createMarketBuyOrder(userMarketOrder, tickSize) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL1Auth();
            const { tokenID } = userMarketOrder;
            tickSize = yield this._resolveTickSize(tokenID, tickSize);
            if (!userMarketOrder.price) {
                const marketPrice = yield this.getPrice(tokenID, types_1.Side.BUY);
                userMarketOrder.price = parseFloat(marketPrice);
            }
            return this.orderBuilder.buildMarketOrder(userMarketOrder, tickSize);
        });
    }
    getOpenOrders(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL2Auth();
            const endpoint = endpoints_1.GET_OPEN_ORDERS;
            const l2HeaderArgs = {
                method: http_helpers_1.GET,
                requestPath: endpoint,
            };
            const headers = yield (0, headers_1.createL2Headers)(this.signer, this.creds, l2HeaderArgs);
            const url = (0, http_helpers_1.addOpenOrderParamsToUrl)(`${this.host}${endpoint}`, params);
            return (0, http_helpers_1.get)(url, headers);
        });
    }
    postOrder(order, orderType = types_1.OrderType.GTC, optionalParams) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL2Auth();
            const endpoint = endpoints_1.POST_ORDER;
            const orderPayload = (0, utilities_1.orderToJson)(order, ((_a = this.creds) === null || _a === void 0 ? void 0 : _a.key) || "", orderType);
            const l2HeaderArgs = {
                method: http_helpers_1.POST,
                requestPath: endpoint,
                body: JSON.stringify(orderPayload),
            };
            const headers = yield (0, headers_1.createL2Headers)(this.signer, this.creds, l2HeaderArgs);
            return (0, http_helpers_1.post)(`${this.host}${endpoint}`, headers, orderPayload, optionalParams);
        });
    }
    cancelOrder(payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL2Auth();
            const endpoint = endpoints_1.CANCEL_ORDER;
            const l2HeaderArgs = {
                method: http_helpers_1.DELETE,
                requestPath: endpoint,
                body: JSON.stringify(payload),
            };
            const headers = yield (0, headers_1.createL2Headers)(this.signer, this.creds, l2HeaderArgs);
            return (0, http_helpers_1.del)(`${this.host}${endpoint}`, headers, payload);
        });
    }
    cancelOrders(ordersHashes) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL2Auth();
            const endpoint = endpoints_1.CANCEL_ORDERS;
            const l2HeaderArgs = {
                method: http_helpers_1.DELETE,
                requestPath: endpoint,
                body: JSON.stringify(ordersHashes),
            };
            const headers = yield (0, headers_1.createL2Headers)(this.signer, this.creds, l2HeaderArgs);
            return (0, http_helpers_1.del)(`${this.host}${endpoint}`, headers, ordersHashes);
        });
    }
    cancelAll() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL2Auth();
            const endpoint = endpoints_1.CANCEL_ALL;
            const l2HeaderArgs = {
                method: http_helpers_1.DELETE,
                requestPath: endpoint,
            };
            const headers = yield (0, headers_1.createL2Headers)(this.signer, this.creds, l2HeaderArgs);
            return (0, http_helpers_1.del)(`${this.host}${endpoint}`, headers);
        });
    }
    cancelMarketOrders(payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL2Auth();
            const endpoint = endpoints_1.CANCEL_MARKET_ORDERS;
            const l2HeaderArgs = {
                method: http_helpers_1.DELETE,
                requestPath: endpoint,
                body: JSON.stringify(payload),
            };
            const headers = yield (0, headers_1.createL2Headers)(this.signer, this.creds, l2HeaderArgs);
            return (0, http_helpers_1.del)(`${this.host}${endpoint}`, headers, payload);
        });
    }
    isOrderScoring(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL2Auth();
            const endpoint = endpoints_1.IS_ORDER_SCORING;
            const headerArgs = {
                method: http_helpers_1.GET,
                requestPath: endpoint,
            };
            const headers = yield (0, headers_1.createL2Headers)(this.signer, this.creds, headerArgs);
            const url = (0, http_helpers_1.addOrderScoringParamsToUrl)(`${this.host}${endpoint}`, params);
            return (0, http_helpers_1.get)(url, headers);
        });
    }
    areOrdersScoring(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.canL2Auth();
            const endpoint = endpoints_1.ARE_ORDERS_SCORING;
            const headerArgs = {
                method: http_helpers_1.GET,
                requestPath: endpoint,
            };
            const headers = yield (0, headers_1.createL2Headers)(this.signer, this.creds, headerArgs);
            const url = (0, http_helpers_1.addOrdersScoringParamsToUrl)(`${this.host}${endpoint}`, params);
            return (0, http_helpers_1.get)(url, headers);
        });
    }
    getMarketTradesEvents(conditionID) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (0, http_helpers_1.get)(`${this.host}${endpoints_1.GET_MARKET_TRADES_EVENTS}${conditionID}`);
        });
    }
    canL1Auth() {
        if (this.signer === undefined) {
            throw errors_1.L1_AUTH_UNAVAILABLE_ERROR;
        }
    }
    canL2Auth() {
        if (this.signer === undefined) {
            throw errors_1.L1_AUTH_UNAVAILABLE_ERROR;
        }
        if (this.creds === undefined) {
            throw errors_1.L2_AUTH_NOT_AVAILABLE;
        }
    }
    _resolveTickSize(tokenID, tickSize) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const minTickSize = yield this.getTickSize(tokenID);
            if (tickSize) {
                if ((0, utilities_1.isTickSizeSmaller)(tickSize, minTickSize)) {
                    throw new Error(`invalid tick size (${tickSize}), minimum for the market is ${minTickSize}`);
                }
            }
            else {
                tickSize = minTickSize;
            }
            return tickSize;
        });
    }
}
exports.ClobClient = ClobClient;
//# sourceMappingURL=client.js.map