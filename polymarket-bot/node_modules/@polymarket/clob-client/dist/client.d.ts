import { Wallet } from "@ethersproject/wallet";
import { JsonRpcSigner } from "@ethersproject/providers";
import { SignatureType, SignedOrder } from "@polymarket/order-utils";
import { ApiKeyCreds, ApiKeysResponse, Chain, MarketPrice, OpenOrderParams, OpenOrdersResponse, OptionalParams, OrderMarketCancelParams, OrderBookSummary, OrderPayload, OrderType, Trade, TradeNotification, TradeNotificationParams, TradeParams, UserMarketOrder, UserOrder, BalanceAllowanceParams, BalanceAllowanceResponse, OrderScoringParams, OrderScoring, OpenOrder, TickSizes, TickSize, OrdersScoringParams, PriceHistoryFilterParams, PaginationPayload, MarketTradeEvent } from "./types";
import { OrderBuilder } from "./order-builder/builder";
export declare class ClobClient {
    readonly host: string;
    readonly chainId: Chain;
    readonly signer?: Wallet | JsonRpcSigner;
    readonly creds?: ApiKeyCreds;
    readonly orderBuilder: OrderBuilder;
    readonly tickSizes: TickSizes;
    constructor(host: string, chainId: Chain, signer?: Wallet | JsonRpcSigner, creds?: ApiKeyCreds, signatureType?: SignatureType, funderAddress?: string);
    getOk(): Promise<any>;
    getServerTime(): Promise<any>;
    getSamplingSimplifiedMarkets(next_cursor?: string): Promise<PaginationPayload>;
    getSamplingMarkets(next_cursor?: string): Promise<PaginationPayload>;
    getSimplifiedMarkets(next_cursor?: string): Promise<PaginationPayload>;
    getMarkets(next_cursor?: string): Promise<PaginationPayload>;
    getMarket(conditionID: string): Promise<any>;
    getOrderBook(tokenID: string): Promise<OrderBookSummary>;
    getTickSize(tokenID: string): Promise<TickSize>;
    /**
     * Calculates the hash for the given orderbook
     * @param orderbook
     * @returns
     */
    getOrderBookHash(orderbook: OrderBookSummary): string;
    getMidpoint(tokenID: string): Promise<any>;
    getPrice(tokenID: string, side: string): Promise<any>;
    getLastTradePrice(tokenID: string): Promise<any>;
    getLargeOrders(minValue?: string): Promise<any>;
    getPricesHistory(params: PriceHistoryFilterParams): Promise<MarketPrice[]>;
    /**
     * Creates a new API key for a user
     * @param nonce
     * @param optionalParams - query parameters
     * @returns ApiKeyCreds
     */
    createApiKey(nonce?: number, optionalParams?: OptionalParams): Promise<ApiKeyCreds>;
    /**
     * Derives an existing API key for a user
     * @param nonce
     * @param optionalParams - query parameters
     * @returns ApiKeyCreds
     */
    deriveApiKey(nonce?: number, optionalParams?: OptionalParams): Promise<ApiKeyCreds>;
    createOrDeriveApiKey(nonce?: number, optionalParams?: OptionalParams): Promise<ApiKeyCreds>;
    getApiKeys(): Promise<ApiKeysResponse>;
    deleteApiKey(): Promise<any>;
    getOrder(orderID: string): Promise<OpenOrder>;
    getTrades(params?: TradeParams): Promise<Trade[]>;
    getTradeNotifications(params?: TradeNotificationParams): Promise<TradeNotification[]>;
    dropTradeNotifications(params?: TradeNotificationParams): Promise<void>;
    getBalanceAllowance(params?: BalanceAllowanceParams): Promise<BalanceAllowanceResponse>;
    createOrder(userOrder: UserOrder, tickSize?: TickSize): Promise<SignedOrder>;
    createMarketBuyOrder(userMarketOrder: UserMarketOrder, tickSize?: TickSize): Promise<SignedOrder>;
    getOpenOrders(params?: OpenOrderParams): Promise<OpenOrdersResponse>;
    postOrder<T extends OrderType = OrderType.GTC>(order: SignedOrder, orderType?: T, optionalParams?: OptionalParams): Promise<any>;
    cancelOrder(payload: OrderPayload): Promise<any>;
    cancelOrders(ordersHashes: string[]): Promise<any>;
    cancelAll(): Promise<any>;
    cancelMarketOrders(payload: OrderMarketCancelParams): Promise<any>;
    isOrderScoring(params?: OrderScoringParams): Promise<OrderScoring>;
    areOrdersScoring(params?: OrdersScoringParams): Promise<OrderScoring>;
    getMarketTradesEvents(conditionID: string): Promise<MarketTradeEvent[]>;
    private canL1Auth;
    private canL2Auth;
    private _resolveTickSize;
}
